<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: src/components/PokerGame/PokerGame.vue</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: src/components/PokerGame/PokerGame.vue</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>&lt;template>
    &lt;section class="gameBoard" v-if="!endScreen">
        &lt;!-- &lt;h1 v-if="maxRoundTimer != 0 &amp;&amp; cardsOn">Temps restant : {{ roundTimer }}&lt;/h1>
        &lt;h1 v-if="maxRoundTimer == 0 &amp;&amp; cardsOn">Temps restant : illimité&lt;/h1> -->
        &lt;h1 v-if="maxDebateTimer != 0 &amp;&amp; debateOn">Temps restant : {{ debateTimer }}&lt;/h1>
        &lt;h1 v-if="maxDebateTimer == 0 &amp;&amp; debateOn">Temps restant : illimité&lt;/h1>
        &lt;div v-for="(task, index) in tasks" :key="index">
            &lt;div v-if="index == taskIndex">
                &lt;h2>Tâche {{ index + 1 }} : {{ task.nom }}&lt;/h2>

                &lt;div v-if="cardsOn" class="cardList">
                    &lt;button @click="cardClick(card)" v-for="(card, index) in cardsImgList" :key="index" :id="card"
                        class="cardBtn">
                        &lt;div :class="{ flipped: cardsOn }">
                            &lt;img class="card-front" alt="Carte"
                                :src="require('@/assets/images/svg/cartes/cartes_' + card + '.svg')">
                            &lt;img class="card-back" :src="require('@/assets/images/svg/cartes/cartes_dos.svg')"
                                alt="Dos carte">
                        &lt;/div>
                    &lt;/button>
                &lt;/div>

                &lt;div v-if="interRound">
                    &lt;p>Difficulté attribuée :&lt;/p>
                    &lt;img alt="Carte"
                        :src="require('@/assets/images/svg/cartes/cartes_' + resultJson.tasks[taskIndex - 1].note + '.svg')">
                &lt;/div>

                &lt;div v-if="debateOn">
                    &lt;h2>Débat&lt;/h2>
                    &lt;form class="chatdiv" @submit.prevent="sendMsg">
                        &lt;div class="chatbox">
                            &lt;div v-for="(msg, index) in msgList" :key="index">
                                &lt;p v-if="msg[1] == this.player.username" class="myMsg">{{ msg[1] }} : {{ msg[0] }}&lt;/p>
                                &lt;p v-else class="otherMsg">{{ msg[1] }} : {{ msg[0] }}&lt;/p>
                            &lt;/div>
                        &lt;/div>
                        &lt;input v-if="debatePermission" type="text" v-model="chatMsg">&lt;button v-if="debatePermission"
                            type="submit" @click="sendMsg">Envoyer&lt;/button>
                    &lt;/form>
                    &lt;p>Tout le monde n'est pas en accord avec la difficulté de la tâche : les deux extrêmes, débattez
                        pour trouver un consensus.&lt;/p>

                    &lt;div v-for="(card, index) in cards" :key="index">
                        &lt;h3>Joueur {{ card[1] }}&lt;/h3>
                        &lt;img alt="Carte" :src="require('@/assets/images/svg/cartes/cartes_' + card[0] + '.svg')">
                    &lt;/div>
                    &lt;button v-if="player.host == true" @click="endDebate">Terminer le débat&lt;/button>
                &lt;/div>
            &lt;/div>
        &lt;/div>
    &lt;/section>

    &lt;section v-else class="endScreen">
        &lt;h2>Fin de la partie&lt;/h2>
        &lt;h3>La partie est terminée, merci d'avoir utilisé notre outil !&lt;/h3>

        &lt;h3>Récapitulatif de la partie :&lt;/h3>
        &lt;div v-for="(task, index) in resultJson.tasks" :key="index">
            &lt;p>{{ task.nom }} :&lt;/p>
            &lt;img alt="Carte" v-if="task.note != ''"
                :src="require('@/assets/images/svg/cartes/cartes_' + task.note + '.svg')">
        &lt;/div>

        &lt;button @click="exportResult">Exporter le résultat&lt;/button>
        &lt;button @click="restartBtn" v-if="player.host">Retourner au salon&lt;/button>
        &lt;p v-if="!player.host">En attente de l'hôte de la partie...&lt;/p>

    &lt;/section>
&lt;/template>

&lt;script>
import { defineComponent } from 'vue';
import 'socket.io-client';

export default defineComponent({
    /**
     * @namespace PokerGame
     */
    name: 'PokerGame',
    homepage: '',

    props: {
        socket: {
            type: Object,
            required: true
        },
        tasks: {
            type: Array,
            required: true
        },
        gameMode: {
            type: String,
            required: true
        },
        // maxRoundTimer: {
        //     type: Number,
        //     required: true
        // },
        maxDebateTimer: {
            type: Number,
            required: true
        },
        currentRoom: {
            type: String,
            required: true
        },
    },

    data() {
        return {
            isKicked: false,
            player: {},
            taskIndex: 0,
            roundTimer: 0,
            interRound: false,
            debateTimer: 10,
            debateOn: false,
            debatePermission: false,
            endScreen: false,
            cardsOn: true,
            cardsImgList: ['0', '1', '2', '3', '5', '8', '13', '20', '40', '100', 'cafe', 'interro'],
            cards: [],
            msgList: [],
            resultJson: { "tasks": [] }
        }
    },

    computed: {
        currentRoomPlayers() {
            return this.rooms.find(room => room.id === this.player.roomId);
        },
    },

    mounted() {

        //Récupération des tâches et des notes si elles existent dans le json importé (reprise de la progression)
        let index = 0;
        this.tasks.forEach(task => {
            if (task.note == "") {
                this.resultJson["tasks"][index] = { "nom": task.nom, "note": "" };
                index++;
            }
            else {
                this.resultJson["tasks"][this.taskIndex] = { "nom": task.nom, "note": task.note };
                this.taskIndex++;
                index++;
            }
        });

        /**
         * Receive the player object from the server
         * @event PokerGame#receivePlayer
         * @param {object} player - The player object sended by the server
         */
        this.socket.on('receivePlayer', (player) => {
            this.player = player;
            console.log("Player : ", this.player);

        });

        /**
         * Receives all the voted cards from the server, validates the difficulty of the current task based on the gamemode or starts a debate if there is no consensus
         * @event PokerGame#allCardsSent
         * @param {object} cards - The object containing voted cards (name and difficulty)
         */
        this.socket.on('allCardsSent', (cards) => {
            setTimeout(() => {

                this.cards = cards;
                this.debatePermission = false;

                //Si toutes les cartes sont les mêmes et que c'est la carte café, télécharger le résultat
                if (cards.every((val, i, arr) => val[0] === arr[0][0]) &amp;&amp; cards[0][0] === 'cafe') {
                    this.endScreen = true;
                }
                else {
                    // Si toutes les cartes sont les mêmes
                    if (cards.every((val, i, arr) => val[0] === arr[0][0])) {
                        this.resultJson["tasks"][this.taskIndex].note = cards[0][0];
                        this.taskIndex++;
                        this.nextStep();
                    } else {

                        //On retire les cartes interro et café
                        const sortedCards = cards
                            .filter(card => card[0] !== 'interro' &amp;&amp; card[0] !== 'cafe')
                            .sort((a, b) => Number(a[0]) - Number(b[0]));

                        // Si une carte est différente
                        if (this.gameMode === 'Unanimité') {
                            this.cardsOn = false;
                            this.debateOn = true;

                            const firstCard = sortedCards[0][0];
                            const lastCard = sortedCards[sortedCards.length - 1][0];

                            sortedCards.forEach(card => {
                                console.log(card[0], firstCard, lastCard);

                                if (sortedCards[0][2] == this.player.socketId || sortedCards[sortedCards.length - 1][2] == this.player.socketId || (card[0] == firstCard &amp;&amp; card[2] == this.player.socketId) || (card[0] == lastCard &amp;&amp; card[2] == this.player.socketId)) {
                                    this.debatePermission = true;
                                }
                            });

                            this.debateTimerStart();
                        }

                        if (this.gameMode === 'Majorité absolue') {

                            //Compter le nombre d'occurences de chaque carte dans le tableau
                            const count = sortedCards.reduce((acc, card) => {
                                acc[card[0]] = (acc[card[0]] || 0) + 1;
                                return acc;
                            }, {});

                            //Si une carte est égale à plus de 50% des votes, passer à la tâche suivante, sinon débat entre la plus petite carte et la plus grande
                            const maxCard = Object.keys(count).reduce((a, b) => count[a] > count[b] ? a : b);
                            const maxCardCount = count[maxCard];
                            console.log("MAX CARD COUNT", maxCardCount);

                            if (maxCardCount > cards.length / 2) {
                                this.resultJson["tasks"][this.taskIndex].note = maxCard;
                                this.taskIndex++;
                                this.nextStep();
                            } else {
                                this.cardsOn = false;
                                this.debateOn = true;

                                const firstCard = sortedCards[0][0];
                                const lastCard = sortedCards[sortedCards.length - 1][0];

                                sortedCards.forEach(card => {
                                    console.log(card[0], firstCard, lastCard);

                                    if (sortedCards[0][2] == this.player.socketId || sortedCards[sortedCards.length - 1][2] == this.player.socketId || (card[0] == firstCard &amp;&amp; card[2] == this.player.socketId) || (card[0] == lastCard &amp;&amp; card[2] == this.player.socketId)) {
                                        this.debatePermission = true;
                                    }
                                });

                                this.debateTimerStart();
                            }
                        }
                    }
                }

            }, 2000);
        });

        /**
         * Receives debate messages from the server
         * @event PokerGame#receiveMsg
         * @param {object} player - The player object sended by the server
         */
        this.socket.on('receiveMsg', (msg, username) => {
            this.msgList.push([msg, username]);
        });

        /**
         * Receives the endDebate event from the server, hides the debate screen, displays the card screen and starts the next task
         * @event PokerGame#endDebate
         */
        this.socket.on('endDebate', () => {
            this.debateOn = false;
            this.cardsOn = true;
            this.chatList = [];
            this.nextStep();
        });
    },

    methods: {

        /**
         * Displays a inter-round screen showing the voted card, or display the end screen if there is no more tasks to vote for
         * @memberof PokerGame
         * @constructor
         */
        nextStep() {

            this.cardsOn = false;
            this.interRound = true;

            setTimeout(() => {
                this.interRound = false;
                this.cardsOn = true;
            }, 5000);

            if (this.taskIndex >= this.tasks.length) {
                setTimeout(() => {
                    this.endScreen = true;
                }, 5000);
            }
        },

        /**
         * Hides the card screen, displays the debate screen and starts the debate timer
         * @memberof PokerGame
         * @constructor
         */
        debateTimerStart() {
            if (this.maxDebateTimer == 0) {
                return;
            }
            else {
                this.debateTimer = this.maxDebateTimer;
                let timer2 = setInterval(() => {
                    this.debateTimer--;
                    if (this.debateTimer &lt;= 0) {
                        this.endDebate();
                        this.debateTimer = this.maxDebateTimer;
                        clearInterval(timer2);
                    }
                }, 1000);
            }
        },

        /**
         * Sends the endDebate event to the server
         * @memberof PokerGame
         * @constructor
         */
        endDebate() {
            this.socket.emit('endDebate', this.currentRoom);
        },

        /**
         * Handles cards animations and sends the selected card to the server
         * @param {string} card - The selected card's name
         * @memberof PokerGame
         * @constructor
         */
        cardClick(card) {
            // document.getElementById(card).firstChild.classList.toggle('flipped');
            document.getElementById(card).classList.toggle('selected');

            const selectedCard = document.getElementById(card);
            const cards = document.querySelectorAll('.cardBtn');

            cards.forEach(card2 => {
                if (card2.id !== selectedCard.id) {
                    card2.firstChild.classList.toggle('flipped');
                }

                document.querySelector(".cardList").style.pointerEvents = "none";
            });
            this.socket.emit('sendCard', this.currentRoom, card, this.player.username, this.player.socketId);
        },

        /**
         * Sends the current debate message to the server
         * @memberof PokerGame
         * @constructor
         */
        sendMsg() {
            if (this.chatMsg) {
                this.socket.emit('sendMsg', this.currentRoom, this.chatMsg, this.player.username);
                this.chatMsg = '';
            }
        },

        /**
         * Exports the current state of tasks with their attributed difficulty to a json file
         * @function exportResult
         * @memberof PokerGame
         * @constructor
         */
        exportResult() {
            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(this.resultJson));
            const downloadAnchorNode = document.createElement('a');
            downloadAnchorNode.setAttribute("href", dataStr);
            downloadAnchorNode.setAttribute("download", "result.json");
            document.body.appendChild(downloadAnchorNode); // required for firefox
            downloadAnchorNode.click();
            downloadAnchorNode.remove();
        },

        /**
         * Send the endGame event to the server
         * @memberof PokerGame
         * @constructor
         */
        restartBtn() {
            this.socket.emit('endGame', this.currentRoom);
        },
    }
})
&lt;/script>

&lt;style lang="css" scoped>
@import url('./test_pokergame.css');
@import url('./pokergame.css');
&lt;/style></code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Namespaces</h3><ul><li><a href="HomePage.html">HomePage</a></li><li><a href="PokerGame.html">PokerGame</a></li><li><a href="RoomOptions.html">RoomOptions</a></li><li><a href="Server.html">Server</a></li></ul><h3>Classes</h3><ul><li><a href="HomePage.back.html">back</a></li><li><a href="HomePage.handleSubmit.html">handleSubmit</a></li><li><a href="HomePage.joinRoom.html">joinRoom</a></li><li><a href="HomePage.joinRoomWithCode.html">joinRoomWithCode</a></li><li><a href="HomePage.reload.html">reload</a></li><li><a href="HomePage.updRooms.html">updRooms</a></li><li><a href="PokerGame.cardClick.html">cardClick</a></li><li><a href="PokerGame.debateTimerStart.html">debateTimerStart</a></li><li><a href="PokerGame.endDebate.html">endDebate</a></li><li><a href="PokerGame.exportResult.html">exportResult</a></li><li><a href="PokerGame.nextStep.html">nextStep</a></li><li><a href="PokerGame.restartBtn.html">restartBtn</a></li><li><a href="PokerGame.sendMsg.html">sendMsg</a></li><li><a href="RoomOptions.copyLink.html">copyLink</a></li><li><a href="RoomOptions.displayHostMenu.html">displayHostMenu</a></li><li><a href="RoomOptions.exitRoom.html">exitRoom</a></li><li><a href="RoomOptions.importJson.html">importJson</a></li><li><a href="RoomOptions.isButtonClicked.html">isButtonClicked</a></li><li><a href="RoomOptions.kickPlayer.html">kickPlayer</a></li><li><a href="RoomOptions.resetPlayer.html">resetPlayer</a></li><li><a href="RoomOptions.sendRoomOptions.html">sendRoomOptions</a></li><li><a href="RoomOptions.setGameMode.html">setGameMode</a></li><li><a href="RoomOptions.setHost.html">setHost</a></li><li><a href="RoomOptions.startGame.html">startGame</a></li><li><a href="RoomOptions.updRooms.html">updRooms</a></li><li><a href="Server.createRoom.html">createRoom</a></li><li><a href="Server.exitRoom.html">exitRoom</a></li><li><a href="Server.findRoomById.html">findRoomById</a></li><li><a href="Server.playerData.html">playerData</a></li><li><a href="Server.roomId.html">roomId</a></li><li><a href="Server.sendCard.html">sendCard</a></li><li><a href="Server.sendMsg.html">sendMsg</a></li><li><a href="Server.sendPlayer.html">sendPlayer</a></li><li><a href="Server.sendRoomOptions.html">sendRoomOptions</a></li><li><a href="Server.setHost.html">setHost</a></li><li><a href="Server.startGame.html">startGame</a></li></ul><h3>Events</h3><ul><li><a href="PokerGame.html#event:allCardsSent">allCardsSent</a></li><li><a href="PokerGame.html#event:endDebate">endDebate</a></li><li><a href="PokerGame.html#event:receiveMsg">receiveMsg</a></li><li><a href="PokerGame.html#event:receivePlayer">receivePlayer</a></li><li><a href="RoomOptions.html#event:endGame">endGame</a></li><li><a href="RoomOptions.html#event:joinRoom">joinRoom</a></li><li><a href="RoomOptions.html#event:kicked">kicked</a></li><li><a href="RoomOptions.html#event:listRooms">listRooms</a></li><li><a href="RoomOptions.html#event:newHost">newHost</a></li><li><a href="RoomOptions.html#event:receiveRoomOptions">receiveRoomOptions</a></li><li><a href="RoomOptions.html#event:startGame">startGame</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Thu Dec 19 2024 11:40:47 GMT+0100 (heure normale d’Europe centrale)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
